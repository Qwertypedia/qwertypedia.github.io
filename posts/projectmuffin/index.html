<!DOCTYPE html>
<html class="staticrypt-html">
  <head>
    <meta charset="UTF-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BmbxuPwQa2lc/FVzBcNJ7UAyJxM6wuqIj61tLrc4wSX0szH/Ev+nYRRuWlolflfl" crossorigin="anonymous"/>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta2/dist/js/bootstrap.bundle.min.js" integrity="sha384-b5kHyXgcpbZJO/tY9Ul7kGkf1S0CWuKcCD38l8YkeH8z8QjE0GmW1gYU5S9FOnJ0" crossorigin="anonymous"></script>
<link rel="stylesheet" href="/assets/css/style.css"/>
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.15.2/css/all.css" integrity="sha384-vSIIfh2YWi9wW0r9iZe7RJPrKwp6bG+s9QZMoITbCckVJqGCCRhc+ccxNcdpHuYu" crossorigin="anonymous"/>
<link rel="icon" type="image/png" href="/assets/images/favicon.png"/>
<title>Project Muffin</title>
<meta name="description" content="It&#39;s secret.">
<meta property="og:title" content="Project Muffin">
<meta property="og:description" content="It&#39;s secret.">
<meta property="og:image" content="/assets/images/index/projectmuffin.png">
<meta property="og:type" content="article"/>
<meta property="og:site_name" content="Project Muffin"/>
<meta property="og:url" content="https://qwertypedia.github.io/posts/projectmuffin/"/>
<meta name="twitter:card" content="summary">
<meta name="twitter:site" content="@KeyboardOSRS"/>
<meta name="twitter:title" content="Project Muffin">
<meta name="twitter:description" content="It&#39;s secret.">
<meta name="twitter:image" content="/assets/images/index/projectmuffin.png">
    <link rel="stylesheet" href="/assets/css/style-staticrypt.css" />
    <link rel="stylesheet" href="/assets/css/style-blog.css" />

    <!-- do not cache this page -->
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
  </head>

  <body>
    <nav class="navbar navbar-expand-sm navbar-light bg-light">
  <div class="container-md">
    <a class="navbar-brand" href="/">
      <i class="fas fa-book-open"></i>
      Qwertypedia
    </a>
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse ml-auto" id="navbarSupportedContent">
      <ul class="navbar-nav ms-auto mb-2 mb-lg-0">
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-bs-toggle="dropdown" aria-expanded="false">
            Posts
          </a>
          <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="navbarDropdown">
            
              <li>
                <a class="dropdown-item" href="/posts/killcredit/">
                  <i class="fas fa-book"></i>
                  Kill Credit Mechanics Explained</a>
              </li>
            
              <li>
                <a class="dropdown-item" href="/posts/killcreditcalc/">
                  <i class="fas fa-calculator"></i>
                  Kill Credit Calculator</a>
              </li>
            
              <li>
                <a class="dropdown-item" href="/posts/projectmuffin/">
                  <i class="fas fa-lock"></i>
                  Project Muffin</a>
              </li>
            
          </ul>

        </li>
      </ul>
    </div>
  </div>
</nav>
    <main><div id="staticrypt_loading" class="staticrypt-spinner-container">
  <div class="staticrypt-spinner"></div>
</div>
<div id="staticrypt_content" class="staticrypt-content hidden">
  <div class="staticrypt-page">
    <div class="d-flex justify-content-center">
      <div class="card p-4" style="width: 100%; max-width: 360px">
        <div class="card-body">
          <form id="staticrypt-form" class="d-flex flex-column align-items-center" style="align-items: center">
            <legend class="text-center fw-bold">Protected Page</legend>
            <p class="mb-4">Encrypted with
              <a href="https://robinmoisson.github.io/staticrypt/" target="_blank">StatiCrypt</a>
            </p>
            <div class="mb-3" style="width: 100%;">
              <input type="password" class="form-control" id="staticrypt-password" placeholder="Password" style="width: 100%; height: 50px">
              <p id="staticrypt-incorrect-password" class="hidden text-danger">Incorrect password!</p>
            </div>
            <div class="mb-3 form-check" style="width: 100%; display: flex; justify-content: flex-start;">
              <input type="checkbox" class="form-check-input" id="staticrypt-remember" style="margin-right: 0.5rem;">
              <label class="form-check-label" for="staticrypt-remember">Remember me</label>
            </div>
            <button type="submit" class="btn btn-primary staticrypt-decrypt" style="width: 100%; height: 50px">Decrypt</button>
          </form>
        </div>
      </div>
    </div>
  </div>
</div></main>

    <script>
      // these variables will be filled when generating the file - the template format is 'variable_name'
      const staticryptInitiator = (function () {
        const exports = {};
        const cryptoEngine = (function () {
          const exports = {};
          const { subtle } = crypto;

          const IV_BITS = 16 * 8;
          const HEX_BITS = 4;
          const ENCRYPTION_ALGO = "AES-CBC";

          /**
           * Translates between utf8 encoded hexadecimal strings
           * and Uint8Array bytes.
           */
          const HexEncoder = {
            /**
             * hex string -> bytes
             * @param {string} hexString
             * @returns {Uint8Array}
             */
            parse: function (hexString) {
              if (hexString.length % 2 !== 0) throw "Invalid hexString";
              const arrayBuffer = new Uint8Array(hexString.length / 2);

              for (let i = 0; i < hexString.length; i += 2) {
                const byteValue = parseInt(hexString.substring(i, i + 2), 16);
                if (isNaN(byteValue)) {
                  throw "Invalid hexString";
                }
                arrayBuffer[i / 2] = byteValue;
              }
              return arrayBuffer;
            },

            /**
             * bytes -> hex string
             * @param {Uint8Array} bytes
             * @returns {string}
             */
            stringify: function (bytes) {
              const hexBytes = [];

              for (let i = 0; i < bytes.length; ++i) {
                let byteString = bytes[i].toString(16);
                if (byteString.length < 2) {
                  byteString = "0" + byteString;
                }
                hexBytes.push(byteString);
              }
              return hexBytes.join("");
            },
          };

          /**
           * Translates between utf8 strings and Uint8Array bytes.
           */
          const UTF8Encoder = {
            parse: function (str) {
              return new TextEncoder().encode(str);
            },

            stringify: function (bytes) {
              return new TextDecoder().decode(bytes);
            },
          };

          /**
           * Salt and encrypt a msg with a password.
           */
          async function encrypt(msg, hashedPassword) {
            // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
            // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
            const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

            const key = await subtle.importKey(
              "raw",
              HexEncoder.parse(hashedPassword),
              ENCRYPTION_ALGO,
              false,
              ["encrypt"]
            );

            const encrypted = await subtle.encrypt(
              {
                name: ENCRYPTION_ALGO,
                iv: iv,
              },
              key,
              UTF8Encoder.parse(msg)
            );

            // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
            return (
              HexEncoder.stringify(iv) +
              HexEncoder.stringify(new Uint8Array(encrypted))
            );
          }
          exports.encrypt = encrypt;

          /**
           * Decrypt a salted msg using a password.
           *
           * @param {string} encryptedMsg
           * @param {string} hashedPassword
           * @returns {Promise<string>}
           */
          async function decrypt(encryptedMsg, hashedPassword) {
            const ivLength = IV_BITS / HEX_BITS;
            const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
            const encrypted = encryptedMsg.substring(ivLength);

            const key = await subtle.importKey(
              "raw",
              HexEncoder.parse(hashedPassword),
              ENCRYPTION_ALGO,
              false,
              ["decrypt"]
            );

            const outBuffer = await subtle.decrypt(
              {
                name: ENCRYPTION_ALGO,
                iv: iv,
              },
              key,
              HexEncoder.parse(encrypted)
            );

            return UTF8Encoder.stringify(new Uint8Array(outBuffer));
          }
          exports.decrypt = decrypt;

          /**
           * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
           *
           * @param {string} password
           * @param {string} salt
           * @returns {Promise<string>}
           */
          async function hashPassword(password, salt) {
            // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
            // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
            let hashedPassword = await hashLegacyRound(password, salt);

            hashedPassword = await hashSecondRound(hashedPassword, salt);

            return hashThirdRound(hashedPassword, salt);
          }
          exports.hashPassword = hashPassword;

          /**
           * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
           * compatibility.
           *
           * @param {string} password
           * @param {string} salt
           * @returns {Promise<string>}
           */
          function hashLegacyRound(password, salt) {
            return pbkdf2(password, salt, 1000, "SHA-1");
          }
          exports.hashLegacyRound = hashLegacyRound;

          /**
           * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
           * remember-me/autodecrypt links, we need to support going from that to more iterations.
           *
           * @param hashedPassword
           * @param salt
           * @returns {Promise<string>}
           */
          function hashSecondRound(hashedPassword, salt) {
            return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
          }
          exports.hashSecondRound = hashSecondRound;

          /**
           * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
           * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
           *
           * @param hashedPassword
           * @param salt
           * @returns {Promise<string>}
           */
          function hashThirdRound(hashedPassword, salt) {
            return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
          }
          exports.hashThirdRound = hashThirdRound;

          /**
           * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
           *
           * @param {string} password
           * @param {string} salt
           * @param {int} iterations
           * @param {string} hashAlgorithm
           * @returns {Promise<string>}
           */
          async function pbkdf2(password, salt, iterations, hashAlgorithm) {
            const key = await subtle.importKey(
              "raw",
              UTF8Encoder.parse(password),
              "PBKDF2",
              false,
              ["deriveBits"]
            );

            const keyBytes = await subtle.deriveBits(
              {
                name: "PBKDF2",
                hash: hashAlgorithm,
                iterations,
                salt: UTF8Encoder.parse(salt),
              },
              key,
              256
            );

            return HexEncoder.stringify(new Uint8Array(keyBytes));
          }

          function generateRandomSalt() {
            const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

            return HexEncoder.stringify(new Uint8Array(bytes));
          }
          exports.generateRandomSalt = generateRandomSalt;

          async function signMessage(hashedPassword, message) {
            const key = await subtle.importKey(
              "raw",
              HexEncoder.parse(hashedPassword),
              {
                name: "HMAC",
                hash: "SHA-256",
              },
              false,
              ["sign"]
            );
            const signature = await subtle.sign(
              "HMAC",
              key,
              UTF8Encoder.parse(message)
            );

            return HexEncoder.stringify(new Uint8Array(signature));
          }
          exports.signMessage = signMessage;

          function getRandomAlphanum() {
            const possibleCharacters =
              "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

            let byteArray;
            let parsedInt;

            // Keep generating new random bytes until we get a value that falls
            // within a range that can be evenly divided by possibleCharacters.length
            do {
              byteArray = crypto.getRandomValues(new Uint8Array(1));
              // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
              parsedInt = byteArray[0] & 0xff;
            } while (parsedInt >= 256 - (256 % possibleCharacters.length));

            // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
            const randomIndex = parsedInt % possibleCharacters.length;

            return possibleCharacters[randomIndex];
          }

          /**
           * Generate a random string of a given length.
           *
           * @param {int} length
           * @returns {string}
           */
          function generateRandomString(length) {
            let randomString = "";

            for (let i = 0; i < length; i++) {
              randomString += getRandomAlphanum();
            }

            return randomString;
          }
          exports.generateRandomString = generateRandomString;

          return exports;
        })();
        const codec = (function () {
          const exports = {};
          /**
           * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
           *
           * @param cryptoEngine - the engine to use for encryption / decryption
           */
          function init(cryptoEngine) {
            const exports = {};

            /**
             * Top-level function for encoding a message.
             * Includes password hashing, encryption, and signing.
             *
             * @param {string} msg
             * @param {string} password
             * @param {string} salt
             *
             * @returns {string} The encoded text
             */
            async function encode(msg, password, salt) {
              const hashedPassword = await cryptoEngine.hashPassword(
                password,
                salt
              );

              const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

              // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
              // it in localStorage safely, we don't use the clear text password)
              const hmac = await cryptoEngine.signMessage(
                hashedPassword,
                encrypted
              );

              return hmac + encrypted;
            }
            exports.encode = encode;

            /**
             * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
             * we don't need to hash the password multiple times.
             *
             * @param {string} msg
             * @param {string} hashedPassword
             *
             * @returns {string} The encoded text
             */
            async function encodeWithHashedPassword(msg, hashedPassword) {
              const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

              // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
              // it in localStorage safely, we don't use the clear text password)
              const hmac = await cryptoEngine.signMessage(
                hashedPassword,
                encrypted
              );

              return hmac + encrypted;
            }
            exports.encodeWithHashedPassword = encodeWithHashedPassword;

            /**
             * Top-level function for decoding a message.
             * Includes signature check and decryption.
             *
             * @param {string} signedMsg
             * @param {string} hashedPassword
             * @param {string} salt
             * @param {int} backwardCompatibleAttempt
             * @param {string} originalPassword
             *
             * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
             */
            async function decode(
              signedMsg,
              hashedPassword,
              salt,
              backwardCompatibleAttempt = 0,
              originalPassword = ""
            ) {
              const encryptedHMAC = signedMsg.substring(0, 64);
              const encryptedMsg = signedMsg.substring(64);
              const decryptedHMAC = await cryptoEngine.signMessage(
                hashedPassword,
                encryptedMsg
              );

              if (decryptedHMAC !== encryptedHMAC) {
                // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
                // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
                originalPassword = originalPassword || hashedPassword;
                if (backwardCompatibleAttempt === 0) {
                  const updatedHashedPassword =
                    await cryptoEngine.hashThirdRound(originalPassword, salt);

                  return decode(
                    signedMsg,
                    updatedHashedPassword,
                    salt,
                    backwardCompatibleAttempt + 1,
                    originalPassword
                  );
                }
                if (backwardCompatibleAttempt === 1) {
                  let updatedHashedPassword =
                    await cryptoEngine.hashSecondRound(originalPassword, salt);
                  updatedHashedPassword = await cryptoEngine.hashThirdRound(
                    updatedHashedPassword,
                    salt
                  );

                  return decode(
                    signedMsg,
                    updatedHashedPassword,
                    salt,
                    backwardCompatibleAttempt + 1,
                    originalPassword
                  );
                }

                return { success: false, message: "Signature mismatch" };
              }

              return {
                success: true,
                decoded: await cryptoEngine.decrypt(
                  encryptedMsg,
                  hashedPassword
                ),
              };
            }
            exports.decode = decode;

            return exports;
          }
          exports.init = init;

          return exports;
        })();
        const decode = codec.init(cryptoEngine).decode;

        function init(staticryptConfig, templateConfig) {
          const exports = {};

          /**
           * Decrypt our encrypted page, replace the whole HTML.
           *
           * @param {string} hashedPassword
           * @returns {Promise<boolean>}
           */
          async function decryptAndReplaceHtml(hashedPassword) {
            const {
              staticryptEncryptedMsgUniqueVariableName,
              staticryptSaltUniqueVariableName,
            } = staticryptConfig;
            const { replaceHtmlCallback } = templateConfig;

            const result = await decode(
              staticryptEncryptedMsgUniqueVariableName,
              hashedPassword,
              staticryptSaltUniqueVariableName
            );
            if (!result.success) {
              return false;
            }
            const plainHTML = result.decoded;

            // if the user configured a callback call it, otherwise just replace the whole HTML
            if (typeof replaceHtmlCallback === "function") {
              replaceHtmlCallback(plainHTML);
            } else {
              document.write(plainHTML);
              document.close();
            }

            return true;
          }

          /**
           * Attempt to decrypt the page and replace the whole HTML.
           *
           * @param {string} password
           * @param {boolean} isRememberChecked
           *
           * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
           *   expose more information in the future we can do it without breaking the password_template
           */
          async function handleDecryptionOfPage(password, isRememberChecked) {
            const {
              isRememberEnabled,
              rememberDurationInDays,
              staticryptSaltUniqueVariableName,
            } = staticryptConfig;
            const { rememberExpirationKey, rememberPassphraseKey } =
              templateConfig;

            // decrypt and replace the whole page
            const hashedPassword = await cryptoEngine.hashPassword(
              password,
              staticryptSaltUniqueVariableName
            );

            const isDecryptionSuccessful = await decryptAndReplaceHtml(
              hashedPassword
            );

            if (!isDecryptionSuccessful) {
              return { isSuccessful: false, hashedPassword };
            }

            // remember the hashedPassword and set its expiration if necessary
            if (isRememberEnabled && isRememberChecked) {
              window.localStorage.setItem(
                rememberPassphraseKey,
                hashedPassword
              );

              // set the expiration if the duration isn't 0 (meaning no expiration)
              if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                  rememberExpirationKey,
                  (
                    new Date().getTime() +
                    rememberDurationInDays * 24 * 60 * 60 * 1000
                  ).toString()
                );
              }
            }

            return { isSuccessful: true, hashedPassword };
          }
          exports.handleDecryptionOfPage = handleDecryptionOfPage;

          /**
           * Clear localstorage from staticrypt related values
           */
          function clearLocalStorage() {
            const {
              clearLocalStorageCallback,
              rememberExpirationKey,
              rememberPassphraseKey,
            } = templateConfig;

            if (typeof clearLocalStorageCallback === "function") {
              clearLocalStorageCallback();
            } else {
              localStorage.removeItem(rememberPassphraseKey);
              localStorage.removeItem(rememberExpirationKey);
            }
          }

          async function handleDecryptOnLoad() {
            let isSuccessful = await decryptOnLoadFromUrl();

            if (!isSuccessful) {
              isSuccessful = await decryptOnLoadFromRememberMe();
            }

            return { isSuccessful };
          }
          exports.handleDecryptOnLoad = handleDecryptOnLoad;

          /**
           * Clear storage if we are logging out
           *
           * @returns {boolean} - whether we logged out
           */
          function logoutIfNeeded() {
            const logoutKey = "staticrypt_logout";

            // handle logout through query param
            const queryParams = new URLSearchParams(window.location.search);
            if (queryParams.has(logoutKey)) {
              clearLocalStorage();
              return true;
            }

            // handle logout through URL fragment
            const hash = window.location.hash.substring(1);
            if (hash.includes(logoutKey)) {
              clearLocalStorage();
              return true;
            }

            return false;
          }

          /**
           * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
           * try to do it if needed.
           *
           * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
           */
          async function decryptOnLoadFromRememberMe() {
            const { rememberDurationInDays } = staticryptConfig;
            const { rememberExpirationKey, rememberPassphraseKey } =
              templateConfig;

            // if we are login out, terminate
            if (logoutIfNeeded()) {
              return false;
            }

            // if there is expiration configured, check if we're not beyond the expiration
            if (rememberDurationInDays && rememberDurationInDays > 0) {
              const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired =
                  expiration && new Date().getTime() > parseInt(expiration);

              if (isExpired) {
                clearLocalStorage();
                return false;
              }
            }

            const hashedPassword = localStorage.getItem(rememberPassphraseKey);

            if (hashedPassword) {
              // try to decrypt
              const isDecryptionSuccessful = await decryptAndReplaceHtml(
                hashedPassword
              );

              // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
              // the user fill the password form again
              if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
              }

              return true;
            }

            return false;
          }

          function decryptOnLoadFromUrl() {
            const passwordKey = "staticrypt_pwd";

            // get the password from the query param
            const queryParams = new URLSearchParams(window.location.search);
            const hashedPasswordQuery = queryParams.get(passwordKey);

            // get the password from the url fragment
            const hashRegexMatch = window.location.hash
              .substring(1)
              .match(new RegExp(passwordKey + "=(.*)"));
            const hashedPasswordFragment = hashRegexMatch
              ? hashRegexMatch[1]
              : null;

            const hashedPassword =
              hashedPasswordFragment || hashedPasswordQuery;

            if (hashedPassword) {
              return decryptAndReplaceHtml(hashedPassword);
            }

            return false;
          }

          return exports;
        }
        exports.init = init;

        return exports;
      })();
      const templateError = "Incorrect password",
        isRememberEnabled = true,
        staticryptConfig = {
          staticryptEncryptedMsgUniqueVariableName: "6acf26cf58088c25782a141c33be177f2df17fd5593bb2c415d9eeb74d7e34084c19df3513224ee191f75f1495cba25b0bd2085933140c63e9c7a6e61f56cd7a3cb7b130cbc52880b24fa382520a7475193feff974b02170a543ace361bead5c223c5e560daa2805b127ff337632303e835f2f06b7124ed535ae6b8c3749040329d833509de587635276ffe11551c3d3ddbc17f7c484380bd900e74a9dd198643e57e97ebd483d9614d6e0d9867694e43fcd8a7d50d143ed14c7a8746ca18e728e90f76a3b2f88dbcac48178900001a2e8cb610174ff388a97e38514b5daaebb3c3a390b32027ab2b2089dc51ba91d73ecfee57320ed69cd2827e52503ad81afbc179140c567ca15702806c1fa0e8196a90d1b1de3124829b304b334eaf5d8e93871bba721c17f0a616113bc401a4329af122d292fea5561d4ff64f2ade63b2f573d6e220ea518eecaa111feca400b2df167748cc856fc1e4d95596c738d72b6f5087fc8fbdf6962393319a62f16008cfca37c6e381d77f1714669eaaa07b1b352d4ca30698943d16de0edfcdf59492386b78729373c8fe8694d8124c3d14b644ee1cbc917bf64a8f8a830832cf1bd3f7070a3e38fc5bd3d463fbe50d1d2f52379b4a48d9b6ee6100b9fe6f68d49635d86d1ad3a5647fa7f21a210da99710eac313d3855176662eb2ebdf6f80aaadf31be1838f71ab5f3241a5e1294fa8efb3db6bbd48ef5b13e7b9cb1007587d53f6768eac513fae320dc02a33c08fb266d5fe06d0cadf4ffd5e8240e103b9ca7c1c4785d4483afae3a585d8cb15790c2c055f7c4b410c51b28a43c474e0a8d8287d9cefc690b44328be0becb2d8a179061b4205de5a6fae35736947e8e7ccda7a04387b47cb6fa73da93ec2a2eb489c75fd7f35b75d0b3212949e5611319b0f4caf5dfd743b2ad4744b287c9b639368c48f3c48b80090206139aa18e4b1d90e62d1d6ce33d8e6749c83b7fb7b85a0554a73b0931bcdbfaf9a9f608d381d89d93af967f2c4f67e995d3bc7c99afe12a9e01a404f688228455b5fa6e4696e0b72548430c461828aba7b89f870bf9aa8a8701a01003554b383fd20e5170b8dfaff81c129db7b889b8f0ef61074a5213ae4a7a4ba5532e0c8de1cb064bc07aa8af09f1f858073516307500a31a7c98f10fc773426dabd7ae3697c96803f46a2e182b8c7cd17395d7f744913722ea132b6b6a0875b9f09d8272a39fdf7da1fd083cf968a05f2a3434eeeacf767093e4623730055820f9746704ee919cff548c53d499339844d433a40b6e1b9d7d1cae0baa5712310eb4e5ed6d13abb33e938bf92e41b496840714b3cae5290db5e5525d4f05416568e44d4bcb78c4f39def9c3b6049b4825c511eb69e322d5ce5ba59864eea34906d986ed3a8d94fbac56e2e91f2b475c741720e4148095b2f8dd12e02bbdca513e0627c0c085cb067e8c77a3418ca041165fd2717da2d24b30bfe3c38d8b76649cae7afa5c855033e5fd9d03e717457c54be466e334e37878d34b501f23e6d6b05977bc3a61869108076733a8bb9b214c64f6536a0c9901fab3c73c94ab4ff193bb6f0e4d6e07bcfc5c068dec2871c7ff961436723b4f7467a415912bb0df1d2a14b43a5c1a4eeab36d1c6f7525c05678529a2e9b62ca6a46531aa5cf12bd825baebb9bc617357e04d609d875dfc530db7a095a9857faa5a0c12a86db2674bae329c4226918a05a17791409ea9ab972cd2ed810d25faebebdf504b197681216bf63d6ad2120c3c591edb68c7d0d1b55c51b95c703b3bc433d44cc80a386b711f4e9ab80ca3b88b22100c8ba2f936861deb3f7896c3ef7e82c6f1209f6af2aa84df9d22a825a2985776fdc124fdc90927d75bbd13b4d0954275d07a0b6023f52495939e71c3b532181db292c073d73e110c1fc19eafef434b22c0c80da39c73f826569ca32aa588931c27a60f2a2c36aeb7475b1a74204da5adf564fd97b37ecd0f238b664121375fc70ad794d1159b28ba6bd0c481c4f88bf2635d1b9a0e3d720d61fbcb57a4230c58cb12786287f8021c929db6974e31868d765b0b42bdd93afdd020942ffa586d07b4d188306a0c7a14fd82c5e5b2169c004e0a6878c4b845bbcb8ffafd5c956c013c7e4f32e09522df59d654078eb4f859a2e692b20c26b67c6a6e4796aed22af123e4de455b53529068755e745a7835a89b727b7c7c4440b5c564edb2af3bdee8d64e9a2d6b9009d12d788520a7dfe466bfda342ea09d2fd4f00961febc6c4bd822ee58995e5adba821246dade0c29890f628cd420094e5a90e7fbdb2868a16c3bb7f485c05f54ffdd884c5941d63e7d238ccd52c3e8d9307491c90a9ed9e78cca95dec685ab65a93cca00ae5b71443ebcb9371ccdbeb18f667150ff7d95638a07b74a387d95ef2851fe76503acfacdfc1d4069ef56314426717a072aa7c55babe058c8cf6f3dc6e24085be81cd8630228cc9f8dc5b4d57ed7b30f943ad8b9ffa3a07ed4c4d8066b8c923f40ffec2cd99a40b409e3ea138ca46f681e0936190c1aac293e9bd51a2fd0e9a104b8f1b4ac5764791cbc4e40a76b3692fcf64b7e547b260def91e806a763d6fad5ca8e1cf44a3b6e8ff3ffc5ac2b45366bab178456530133db3edba12c258171c0b008e0dca527bf0424afefbdfce9b8a27a24ffbab1ee8431adc44607f2a2a5349e4957ef3710eca2cfeaf3170e1d454481978802179c462d4d6aa7f6cc12b0b8a7071cc64aceedf3f7610ec7aab14c8b45ea9bcc41bddc674e266f51f18e74b0a9a6a2f6034863acb6ec8c13c857a78c90a80a299177367b30f7737701aaf579d9af522adaf41a86bad7f4e98a23070752a81449954c823973eaba747a700530f8633d270b361507ac91b91c381501c3468072db7fd623e04a8cbfee29dab9e079c4632bbb29a9eedd4a52ce9ae7658effe4096c854a9a558cac515bc656e6f18bcf6331d83a38625e31ed68be8fdb75699566848a4bb88cefe9e6b87c04e1235b96cf0153325039aab51839a30bcdaaeee4f468a1609d32cc789f963b9b89942c85f57f2c85c93d86aafda4735077715b8036daece0c9ca41f8edebe8e9ce12e917f2f828464341d87998eaac112eece2246515ecd3ab3695e9a73e13f48a07d7164569bf8cb55634d7f9b3c88c4bb1bac6ba44714bd49b92d3835203c082c8ae5491909b6ed8d90fcee6806d709f9b33fd98b6b0ced922dd6e69ff4cfd2e2839b62da4f86a465e696aa7c30895f4de555f38b253f71d4295b88df7adffa2d17ec1633eb0253b7b1d39d8ea166586bd8ac5b6ab295305dc1b107c0922f95fa44f6f32fdc016900c8072372536d40027039bcb5c86f1b46c85bd4b99faff60cbcbaf5c4e021fd9cdbe88d09b59008a39652b672ccf7e749c0ade9a14768a36f8caa10f9bd3b4450e4eb27d71d0c971fbd0bd8fe0e39c689aaa505f898eab0edd8a5dbd1d58a633859bea0be6b42271735957d19da895cc270bbf6bca2f12640f44d2f33508bc7b6c9b3af1388e9316f1915c48e8e391cad9d2e355a42ff41ebb2721ae19643ffd2e10a5dd9e4fda0dd4867d45a13f743504ac5c15078a3d5ae95d2e398eb857519731388e7f62d7fae3a56051c6148c2591a4eaaaa9fee5091c26546e59ea1aea15e3ac75fe4b4fecf1fc527629147bc7d0126a9bae4598e788c511d34502bde68dc22e8ecfe20975622ba34182e499b7e87ede5b7e0651fdc70c706e72a248a255817fb5db917362bddc518989d5c07752cf7d5260924fc41b405f0f2e3816626279ad07f6e1fe596bced5525c2ca09a1046e7242857cae9f6060a089cd7b43c4aa4c91b9788fb38eea8b87a21332bede4de8093b1ff974965175b07c5a74c43dfc25c27e43cddd897970613afc4077b456ad8408f10ea4fb73695a618394b0b6239a303a59b14faad978883abcd846d230af6dd867d667aefcda8e0fa23e0124cc2582e02014943725068070e876e02da7ac54bd58a1c69ad3ee99e8eacff3b00661e0141b6707cbf891e89dd3a960fb5b1bfd98cff89156a2b7c574267723282530e35c6a816e1fd2f0fd8fda3e241c132ce8b6e9ad1f3063478b7287d60e3fc7e4bb9965235d5abed8a022d528995fd43ab4357499413e71845b615be685f7289f85ba162dccf66b956c48a2d48d5f846201a8c1f05c869e962ee49c19ab968c9feca8bc296b5469fe3cb703776da58207f6ac01e8f54cd300f0efdd76b760150f232e70189fcc0d31945112c46c8a5b7950b2dad1b20fcc15b898fc31cec72216ccc59eb88752ef50da41bfda5af390b4846cb415382f8052b469d9c10da79600b02c287b87b309c1dbe8b8fa893ad1d42e24f11845fb397165e86c1f0928aec6970f477953254994f43b4b12f68f958e48fbb42e9a7523a09695c7db7e3785db74bd5d00bc7abe381a71c1b0e44e578d57c29be1233930ab5dcd1b54606cab922dbe52d936384248759b31b77ede1626f9ed3cc6f940a3f25100857597d4be1bbcfea7d7d39104da3a52c88074a434a7ae986cb0880a539b77fdee781cf5140bc272cbf678c4fa7ebb1f3cccfee000acb7953790b9d9b2aa36c6fa1a5c8959609904fbc054412731f115b6892cd6b6027afad78537e8687770d2bde297d8c0fa0eed7641a68b26a8dc0c4b39ebac7be88b691d4472e6981796f9a059a1b7ff89bafe1b77e2fa611f8374786ad672e1909b1e01513e67ae4b5f89bf5083d7136dabc65175ac2571d89586dfbbac98d9e566aa426c46fe59bfee7a6b163df08476600ee08ace0eea3d85d258c220a380a6eb3ae3051c1feebe6fcd1c1a7f7cabd675dfa60ecad287a39d7d0c548d78d1be808c7617e3e96a8bfc298bdf74b1597d31975b04baa3d804d41b6cacac4dbe8070388fcb66797081a81a98d5ad2a4c6a0d556f99620b20eae40129da0f35cd33ea6284582205054054b8bc0e56571f19ddace96a31ab8e59f77d79c2d9464b71092a643d913b57eb5b584e926e95932c38a4d5a62749811f655220381ccddfb495305bb9cbaa72320aef8b59b404161a4d9937202b5d5015c84e0064088817a038e7a4c9fd7d4e9708dfdc4aef354c383270f1ba515ed93587e3018d740573bd0e384c41dabfa3989257d6f8fc28452a1f177f1617870e29b98ce5a68e5d7ac141e4f180c947bd827cb1911bb8558df0bee84a630df7c52e36b0e94bdd12dcbf65bb737b6661ab3bf2cd72af27f9afcad71ec66b45c54dc3428391ef8db9ad4a8f69c2eb594e4c6eabb49d8779d049caf55ba489ea615aafd2c0fd1feae148c0eda8193d452b354468b4ef7a0e884a94b5a568c7c1109338366c22a9e8c675c46f0bbd70c94abe4d1a2b59f57bef0ed324f794344403c44ed662bc882dc978969e33eaf935a5eed57ef14876c214c3c2d1c67fb147a6b51b9b230c8046eb04634e6854cd3fed013a0e490b28f3c52ef027a8492d8d1450301870e98e5d58d8778d844ae29a93041418d2149667337fc9ed48bf21900a06b98e428142d4c4becdd09c237dbeef079aaf9eeac115df09046dbf33efb9e1a38100d9962721106311c7230dcede31a6bd5310d5423480e9dd12aae74f8a512f4a9f382ee9ba83dc05acc06c59e95f76a1080ae50118b54b7e32028f1f3e2396d41cf60cb7e32f21cd0eefadff15cef4ca50f7bac6d6927caf6798fdc95be60cf5fc007c1b32a129db33672e7c9c019814b134f9112ad51ea83e966df7950f235cdc1bedfb22d8a170aa9f4fc8ec8210df3269dd39d68ff5b8a779eef4ef179f9991981e2b00388bbf9a878229b690eb98f614aff3fb35ce57be16f0045c4cc86aa35c89ef7febedf9b597c70f7578175405ed3f4daafb72d5c575197748c0a0645771e54ab269f7165ff313df8d6d93946347577889b7e1ea8c3db58a2b04cc6595d90085afd3372c34d5fcd220045dc5d6266846ab3af32bac99025ac624ec777e8c43aab4ce6f0dc4b524abb3b749ab134da73156c0e78197b6a167aaaeb4b7fb4b8a97a85e7058a06dde9093fa92a0bff4f6b5b553f31effc251100e72790a18455e09b004167b027ca3d4ddbb94d373f9a2400aa4a4dc462c9c98f020962f83822e460b73ef6afe7fb100d64289de4d3baab420ad60d603b8acc57d3af5d15e5ff46d2668f4b17a9d72231d38da6065b8a308fd8caa52581c1eaaf8254dbde039527bdb29b9dadc51720ddcf7027cca428781ce2b8ae3c44ecaf25cc22e02fb1abe252a4d63c052f7144d4276a46b12b1b36dfa92c07de2c1c2efb1b3c5f84043e9b70972fa014e5469965655f34ca42fedd5248c8e506555dae578b5bed557ddd9dde6c7afe24bd40215de5e00aaa9ffa4eda0c94b0cd670ebe8fa49732e71298420c382b19c0ee9a8e734fb6a80db79d2eb12e555e0a07c25a2fe4d37e6281e9b4ad6b3c77730776b850597d1f192972452dee3c0762c189fcaa8b06272dd08cde2a2740ad27e5a50f29c359c6b283196d34e7e29d0068692d0a2f0a2582bc53f12b744e3cb4023eaac470aa3085f11a9020166698eecbdc1f7a2e423f568950d59a9ef6d8c9332d841323a685f3c1f3d27d7ce5cbc1cdd4b592d41f554e612d6357607eabc3d2fb5b2a2728f09ea8fd9956154a07c8afc38fe2a7d2cf587cc8e0abc86f83e044fbaf53a39f26cbe91e79f6677bcb75eb0bef62aa822d6192e0e6dce06b82da6224b5119f2a580ee80ab6ca9e0046ba83c85f2dbce3783c43c8599c852786ac02de7250801ab911f1edc54dfa30df7f2011e6970f4777a88c0f366280186b382fb049ba19574c5c202ed851eaef9a8c5bdbeb8f055b755141afff98e621e9134b6ecb27d25323b8df7166259108792353aab2fdf0e95e78b06273054b58a119be30ac5ac2288748013abf6b5004aededc195bd07998d82c6812f4abc71a3c10fb9d97c7b0732b6cf542e4442f30344fd2337be77a5d3060010ef07d272ad01ad3918aec06859a1177a46b8b4dfe3f78bc3f643d1c92109806e15a5065fd5caccefa4ab0ba1980db2edd589a593c961e88661e4c967f6d0f3470579efca3725f11ee410c29d7d12dfd0d5f62c2876f99fe6c84564d42da9091a8a8d6704e513865b9b281c5962c73f3ea76c193a0aea37f71b45aeaccfd73542e84be3b630a051bb6be04efe809b812952aaf89aaaf78df51af8848273d16d47a8d6b8139784e499daf065ef9a5c675a6723267887f0d2af54c37e2e92e2e0fd9cf58ce1871eee0c352bfa6780040a3f7eba7af1fec1eb6785eb35643f9ff1bec4aab5166b6ae70f4c30d6a98c0ab12857df7ecdfecdc39a3de65f10b156e0c10093e2536569fc58f9a50ef27bd8603cd0733592db9cbedb6e06bdb3772fa3715d338d901b4c7c3ceba594488c131bf99bf9f2cee679fa537b6cc674f6083f6e193f3e49cd271db9a317c142944525eaf4b531ddd908ed15738c09cd3560c50f25de72d0082769c5763bbd48be107c0e29ae031c6e9a7b82ad0ce5cc8212fe980048269d278d780172a0f9df30fe1766b61863cf570266394454c24e90f85c5f62d5883927c3cf8cffb687f23a7e5eb7673a113f9ab4d95374ba8ebe20c69ac88d4005a5d2d434481d2a671bf6e6312262f6f2cd309485a8d082bae03ac4007e4bf24490dad2874af31c60fe6bfc65feca098015d27d9e1e276f808d27f41a94d99b1a6a9564eb459afa1b190ec6283cf3c569540c70fbd4efc84841bb4b73d4dca3eb1905b122097451ecd522c2978ff2cb1df49d713b16eac08ccd6a1a6b86bc75bff3407f203e6f8f52a0125f7a6c1d73d2287ab53634b55d3d1463992417702c0b80cd241754b04efff0e5707cb4e5ec11610acb9354ee63071e46dd2633834e2705f76673f56db1a149ed44bfaf40ae85c4839f7648d2da84ce6ffdbf54d0f23dc035ee9a317a9d8176f2027e675ec4aabaecf7921f529a6371a68fa12c9c7f46e63dc330361bdd54fc3f9f8518c2bbd6029921b96b13fd23bb0640f9df346504381622f4694a0d308dd4631f6deb74586af885d527355fde4ad8d82bbc716ed26d1cb4c3d38af977a6067f2f59d8f533370dcc49b4a0646f40c630a4b27b84d0e1a1b901544f0bbb2fdcc25baf094962c2b45bf641eb79865e12932f5b7930413292c0fa0cfbb29c5fc9ec79d02a63a25d06cb9c84d2803cdf967bfc825128edc2d1da343c871786fc3e15e89eef281a5a7c91447ddad2d0eed7d5f17e9239122193a869a83535f4565bcc01c3b1e2f8f513b1d57aa5c7b18176d2178e893321535941307c5c6fe69df9944d2b48e55bed83798aa831f7054a0bbdc728fd1459969b408a593f037dda02922143ee0d5e7431536f2d37e1ea76b91bdcf49bc4cb25eea5eeb21b6374bbb5ca0d657f9db9491fe949519a599c0831d1514672331abbb3c20538ec9e803dd89b61c06c096b0922c4802096040b368a27dd99a2e23eafc1022620b9767ff38873b854ca269816f6e60eb33e86fc7556d55e2c2de317069b86324b2f300b1543101ca6be397b68cae9bbf261463d815ebf3e07f52b1b38bce0192460126d23ae94adaf735c2934fd1cea9d87a9b7bccd6fd4a901e24598de89635f3addff3e5b6bc0c630806b5fbe3b8c8e116f8e04c49e72e2b117f1c4a50ad95c90877fdf41dd74fa52be97912ae088af141c8100bbf204fc56c92aee5e66fa52f7bfde043193b49a55e70d4b207625971f80375ba3303788c549bd4752bc688af7766e811e1d7a2a47c8037c27502aa343a2f21715ec3aeafce5fea23ab227b0ba7c686cdf80f2617c4c67ebea19ec1be2ae5e90b572460f435d0260cd9dc8e2abbbdfd897757d0afcdfe2835041751089962d02b67e46802959663e01f9998593ff8c7761061a0121e7421732d5145dadb08cc90321ad57c682cc22eda4d71f8b4d8892129761b439022c49263417d8fb89f3feff9212202c5c911785f054e1bacd84cf42e9146a1d4f0411780e0ebc7630a727ee9a30c907d3dd0f4c949373cfaf9f8006346ebd91a6704f3908aebd8c793eed585d8522e5569d3bd1e31e92bd22ea249e0f12434c3bfdeb9ee43fc05a6e53ba58327c0f37e7616b929eb198badba7f866048a52fb4968e6135cb7dc4f28a671293e7c1c9c146ba091a736e1da4ee14f812fe612794e267843a56cda3a967e9620a6eaf2a90450c146cc58a4bf2a7104567d5f7320e0a0ac387cc61d46ad7f8fe55edba12ca4207ef7fe1c1157cebc59ceb94f704d05877a8eba79f492ea4ac0ed6a290ca2e5fed2631b57b26e49e4c4d22224aad3cd765a0a0b5fdddbec0ce8d3fba6ce0e4f0714ad192a4ec1eb994e293caedce2472f9ca58a61e55d9cc327200794f4f5915c1ac8f09d4a5c9d68799999106765202ce75e494ec27",
          isRememberEnabled: true,
          rememberDurationInDays: 0,
          staticryptSaltUniqueVariableName: "994e326ef32db88c1599c0010188e96c",
        };

      // you can edit these values to customize some of the behavior of StatiCrypt
      const templateConfig = {
        rememberExpirationKey: "staticrypt_expiration",
        rememberPassphraseKey: "staticrypt_passphrase",
        replaceHtmlCallback: null,
        clearLocalStorageCallback: null,
      };

      // init the staticrypt engine
      const staticrypt = staticryptInitiator.init(
        staticryptConfig,
        templateConfig
      );

      // try to automatically decrypt on load if there is a saved password
      window.onload = async function () {
        const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

        // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
        // replaced, no need to do anything
        if (!isSuccessful) {
          // hide loading screen
          document.getElementById("staticrypt_loading").classList.add("hidden");
          document
            .getElementById("staticrypt_content")
            .classList.remove("hidden");
          document.getElementById("staticrypt-password").focus();
        }
      };

      // handle password form submission
      document
        .querySelector(".staticrypt-decrypt")
        .addEventListener("click", async function (e) {
          e.preventDefault();

          const password = document.getElementById("staticrypt-password").value,
            isRememberChecked = document.getElementById(
              "staticrypt-remember"
            ).checked;

          const { isSuccessful } = await staticrypt.handleDecryptionOfPage(
            password,
            isRememberChecked
          );

          if (!isSuccessful) {
            document
              .getElementById("staticrypt-incorrect-password")
              .classList.remove("hidden");
          }
        });
    </script>
  </body>
</html>
